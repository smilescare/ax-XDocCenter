/* * Toaster Component * dojoc.Toaster * Message that slides in from the corner of the screen, used for notifications like "new email" */define("dojoc/Toaster", [ 	"dojo/dom",	"dojo/dom-geometry",	"dojo/dom-construct",	"dijit/_base/place",	"dojoc/Toast",    "dojo/fx",    "dojo/_base/declare",    "dijit/_WidgetBase",    "dijit/_TemplatedMixin",    "dojo/dom-style",    "dojo/text!./templates/Toaster.html"], function(dom, domGeometry, domConstruct, place, toast, fx, declare, _WidgetBase, _TemplatedMixin, domStyle, template){    return declare("dojoc.Toaster", [_WidgetBase, _TemplatedMixin], {        // template contains the content of the file "templates/Toaster.html"        templateString: template,                // messageTopic: String        //		Name of topic; anything published to this topic will be displayed as a message.        //		Message format is either String or an object like        //		{message: "hello word", type: "error", duration: 500}        messageTopic: "",        _uniqueId: 0,                // positionDirection: String        //		Position from which message slides into screen, one of        //		["br-up", "br-left", "bl-up", "bl-right", "tr-down", "tr-left", "tl-down", "tl-right"]        positionDirection: "br-up",                // positionDirectionTypes: Array        //		Possible values for positionDirection parameter        positionDirectionTypes: ["br-up", "br-left", "bl-up", "bl-right", "tr-down", "tr-left", "tl-down", "tl-right"],                //defines how the messages will be added when another is showing.  If appendMessage=true a message will be added to the end, otherwise it will be added at the start.        appendMessage: true,                // slideDuration: Integer        //		Number of milliseconds for the slide animation, increasing will cause the Toaster         //    to slide in more slowly.        slideDuration: 500,                // viewport: String|Node         // Optional nodeId or node that will dislay the toaster.  By default the toaster is appended in documents the body element.        viewport: "",                // topic: Object        // references the returned topic handler, used on destroy to un-subscribe from the topic        _topic: null,                postCreate: function(){        	this.inherited(arguments);        	this._hide();        	        	// place node as a child of body for positioning        	if(!this.viewport){        		dojo.body().appendChild(this.domNode);        	}else{        		dom.byId(this.viewport).appendChild(this.domNode);        	}        	        	if(this.messageTopic){        		this._topic = dojo.subscribe(this.messageTopic, this, "_handleMessage");        	}        },                destroy:function(){        	dojo.unsubscribe(this._topic);        	this.inherited(arguments);        },                _handleMessage: function(/*String|Object*/message){        	if(!message) return;        	if(dojo.isString(message)){        		this.setContent([{"message":message}]);        	}else if(message.messages){        		this.setContent(message.messages);        	}else{        		this.setContent([message]);        	}        },                setContent: function(/*[messageObj]*/messages){        	// summary:        	//		sets and displays the given array of message objects and show duration        	// messageObj:        	//		message:         	//			the message. If this is a function, it will be called with this toaster widget as the only argument.        	// 		type:        	//			type of message; possible values in messageTypes enumeration ("message", "warning", "error", "fatal")        	// 		duration:        	//			duration in milliseconds to display message before removing it. Widget has default value.        	        	// sync animations so there are no ghosted fades and such        	if(this.slideAnim){        		if(this.slideAnim.status() != "playing"){        			this.slideAnim.stop();        		}        		        		if(this.slideAnim.status() == "playing"){        			setTimeout(dojo.hitch(this, function(){        				this.setContent(messages);        			}), 50);        			        			return;        		}        	}        	        	domStyle.set(this.containerNode, "opacity", 1);        	        	var loaf = this._createToast(messages);        	        	if(this.isVisible){        		/* Toaster is currently showing so just adjust the clip node size around the contents */        		this._placeClip();        		this._connectToToastFadeOut(loaf);        	}else{        		/* Toaster is not showing so setup the slide animation on the container node */        		// now do funky animation of widget appearing from        		// bottom right of page and up        		this._show();        		var nodeSize = domGeometry.getMarginBox(this.containerNode);        		var style = this.containerNode.style;        		var pd = this.positionDirection;        		// sets up initial position of container node and slide-out direction        		if(pd.indexOf("-up") >= 0){        			style.left="0px";        			style.top = nodeSize.h + 10 + "px";        		}else if(pd.indexOf("-left") >= 0){        			style.left = nodeSize.w + 10 +"px";        			style.top="0px";        		}else if(pd.indexOf("-right") >= 0){        			style.left = -nodeSize.w - 10 + "px";        			style.top = "0px";        		}else if(pd.indexOf("-down") >= 0){        			style.left = "0px";        			style.top = -nodeSize.h - 10 + "px";        		}else{        			throw new Error(this.id + ".positionDirection is invalid: " + pd);        		}        		        		/* create the slide animation based on the dimensions calculated above */        		this.slideAnim = dojo.fx.slideTo({        			node: this.containerNode,        			top: 0, left: 0,        			duration: this.slideDuration});        		        		this.connect(this.slideAnim, "onEnd", function(nodes, anim){        			this.isVisible = true;        			this._connectToToastFadeOut(loaf);        		});        		        		this.slideAnim.play();        	}        },                _createToast: function(messages){        	if(!messages) return;        	var loaf = [];        	dojo.forEach(messages, function (message){        		loaf[loaf.length] = new toast(message);        		domConstruct.place(loaf[loaf.length-1].domNode, this.containerNode, this._calculatePlacementValue());        	}, this);        	        	return loaf;        },                _calculatePlacementValue: function(){        	if(this.positionDirection.indexOf("b") == 1)        		return this.appendMessage ? "first" : "last";        	else        		return this.appendMessage ? "last" : "first";          },                _placeClip: function(){        	var view = place.getViewport();        	var nodeSize = domGeometry.getMarginBox(this.containerNode);        	var style = this.clipNode.style;        	        	// sets up the size of the clipping node        	style.height = nodeSize.h+"px";        	style.width = nodeSize.w+"px";        	        	// sets up the position of the clipping node        	var pd = this.positionDirection;        	if(pd.match(/^t/)){        		style.top = view.t+"px";        	}else if(pd.match(/^b/)){        		style.top = (view.h - nodeSize.h + view.t)+"px";        	}        	        	if(pd.match(/^[tb]r-/)){        		//TODO al7689 :: does this work better?        		//style.left = (view.w - nodeSize.w - 1 - view.l)+"px";        		style.right = "0px";        	}else if(pd.match(/^[tb]l-/)){        		style.left = "0px";        	}			//TODO: Need to check the need for below clipping        	//style.clip = "rect(0px, " + nodeSize.w + "px, " + nodeSize.h + "px, 0px)";        },                _show: function(){        	// summary: show the Toaster        	domStyle.set(this.domNode, 'display', 'block');        	this._placeClip();        	if(!this._scrollConnected){        		this._scrollConnected = dojo.connect(window, "onscroll", this, this._placeClip);        	}        },                _hide: function(){        	// summary: hide the Toaster        	domStyle.set(this.domNode, 'display', 'none');        	        	if(this._scrollConnected){        		dojo.disconnect(this._scrollConnected);        		this._scrollConnected = false;        	}        	        	domStyle.set(this.containerNode, "opacity", 1);        	        	this.isVisible = false;        },                _connectToToastFadeOut: function(loaf){        	dojo.forEach(loaf, function(toast){        		this.connect(toast, "_hide", function(evt){        			this._placeClip();        			if(dojo.query(".dijitToast", this.clipNode).length == 0){        				//this._hide();        				this.clearMessages();        			}        		});        		toast.startHideTimer();        	}, this);        },                clearMessages: function(/*?function?*/fn){        	dojo.query(".dijitToast", this.clipNode).forEach(function(toastDomNode){        		console.log("clearing messages...");				domConstruct.destroy(toastDomNode);				console.log("messages cleared...");				/*        		var toast = dijit.byId(toastDomNode.id);        		        		if(toast){        			if(dojo.isFunction(fn))        				fn(toast);        			else        				toast.destroy();	        		}        		*/	        	});        	        	if(dojo.query(".dijitToast", this.clipNode).length == 0)        		this._hide();        }    });});